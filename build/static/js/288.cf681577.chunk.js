"use strict";(self.webpackChunktracker=self.webpackChunktracker||[]).push([[288],{6288:(t,e,a)=>{a.d(e,{localDynamo:()=>o});var r=a(7051),s=a(5806);s.db.open().catch((t=>{console.error("Failed to open database:",t)}));const o=new class{async put(t){const{Item:e}=t,a=this.getTableNameFromItem(e);try{switch(a){case"individuals":await s.db.individuals.put(e);break;case"grants":await s.db.grants.put(e);break;case"workdays":await s.db.workdays.put(e);break;case"workdayHours":await s.db.workdayHours.put(e);break;case"timeslots":const t=e;await this.validateTimeSlotConstraints(t),await s.db.timeslots.put(t);break;default:throw new Error("Unknown table: ".concat(a))}}catch(r){throw new Error("Put operation failed: ".concat(r))}}async get(t){const{Key:e}=t,a=this.getTableNameFromKey(e);try{let t;switch(a){case"individuals":t=await s.db.individuals.get(e.PK);break;case"grants":t=await s.db.grants.get(e.PK);break;case"workdays":t=await s.db.workdays.get([e.PK,e.SK]);break;case"workdayHours":t=await s.db.workdayHours.get([e.PK,e.SK]);break;case"timeslots":t=await s.db.timeslots.get([e.PK,e.SK]);break;default:throw new Error("Unknown table for key: ".concat(JSON.stringify(e)))}return t?{Item:t}:{}}catch(r){throw new Error("Get operation failed: ".concat(r))}}async deleteItem(t){const{Key:e}=t,a=this.getTableNameFromKey(e);try{switch(a){case"individuals":await s.db.individuals.delete(e.PK);break;case"grants":await s.db.grants.delete(e.PK);break;case"workdays":await s.db.workdays.delete([e.PK,e.SK]);break;case"workdayHours":await s.db.workdayHours.delete([e.PK,e.SK]);break;case"timeslots":await s.db.timeslots.delete([e.PK,e.SK]);break;default:throw new Error("Unknown table for key: ".concat(JSON.stringify(e)))}}catch(r){throw new Error("Delete operation failed: ".concat(r))}}async query(t){try{return{Items:[]}}catch(e){throw new Error("Query operation failed: ".concat(e))}}async batchWrite(t){const{RequestItems:e}=t;try{await s.db.transaction("rw",[s.db.individuals,s.db.grants,s.db.workdays,s.db.workdayHours,s.db.timeslots],(async()=>{for(const[,t]of Object.entries(e))for(const e of t)e.PutRequest?await this.put({Item:e.PutRequest.Item}):e.DeleteRequest&&await this.deleteItem({Key:e.DeleteRequest.Key})}))}catch(a){throw new Error("Batch write operation failed: ".concat(a))}}async transactWrite(t){const{TransactItems:e}=t;try{await s.db.transaction("rw",[s.db.individuals,s.db.grants,s.db.workdays,s.db.workdayHours,s.db.timeslots],(async()=>{for(const t of e)t.Put?await this.put({Item:t.Put.Item}):t.Delete?await this.deleteItem({Key:t.Delete.Key}):t.Update&&await this.update(t.Update)}))}catch(a){throw new Error("Transaction write operation failed: ".concat(a))}}async update(t){const{Key:e,UpdateExpression:a,ExpressionAttributeValues:r}=t;try{const t=await this.get({Key:e});if(!t.Item)throw new Error("Item not found for update");const s=this.applyUpdateExpression(t.Item,a,r);await this.put({Item:s})}catch(s){throw new Error("Update operation failed: ".concat(s))}}getTableNameFromItem(t){if("FirstName"in t&&"LastName"in t)return"individuals";if("Title"in t&&"StartDate"in t)return"grants";if("Workdays"in t)return"workdays";if("Hours"in t)return"workdayHours";if("AllocationPercent"in t||"HoursAllocated"in t)return"timeslots";throw new Error("Cannot determine table from item structure")}getTableNameFromKey(t){if(!t.SK)return t.PK.startsWith("U-")?"individuals":"grants";if(t.SK.startsWith("WORKDAYS#"))return"workdays";if(t.SK.startsWith("WORKDAY_HOURS#"))return"workdayHours";if(t.SK.includes("#G-"))return"timeslots";throw new Error("Cannot determine table from key structure")}applyUpdateExpression(t,e,a){const s=(0,r.A)({},t);if(e.includes("SET")){const t=e.split("SET")[1].split("ADD")[0].split("REMOVE")[0].trim().split(",");for(const e of t){const[t,r]=e.split("=").map((t=>t.trim()));a[r]&&(s[t]=a[r])}}return s}async validateTimeSlotConstraints(t){const e=[...await s.db.timeslots.where("PK").equals(t.PK).and((e=>e.Date===t.Date&&e.SK!==t.SK)).toArray(),t];if(!(0,s.QQ)(e))throw new Error("Total allocation percentage cannot exceed 100%");const a=new Date(t.Date).getFullYear(),r=await s.db.workdayHours.get([t.PK,"WORKDAY_HOURS#".concat(a)]),o=null===r||void 0===r?void 0:r.Hours[t.Date],i=o?(0,s.getHoursFromDayEntry)(o):s.yS;if(!(0,s.HU)(e,i))throw new Error("Total allocated hours cannot exceed ".concat(i," hours for this day"))}}}}]);
//# sourceMappingURL=288.cf681577.chunk.js.map