{"version":3,"file":"static/js/288.cf681577.chunk.js","mappings":"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","sources":["db/localDynamo.ts"],"sourcesContent":["import {\n  db,\n  Individual,\n  Grant,\n  Workday,\n  WorkdayHours,\n  TimeSlot,\n  DynamoDBKey,\n  DynamoDBItem,\n  QueryParams,\n  PutParams,\n  GetParams,\n  DeleteParams,\n  UpdateParams,\n  BatchWriteParams,\n  TransactWriteParams,\n  validateAllocationPercent,\n  validateHoursAllocated,\n  DEFAULT_WORKDAY_HOURS,\n  getHoursFromDayEntry,\n} from \"./schema\";\n\n// Initialize database on import\ndb.open().catch((err) => {\n  console.error(\"Failed to open database:\", err);\n});\n\n// DynamoDB-compatible API facade for IndexedDB\nexport class LocalDynamoDB {\n  // Put operation - Insert/update single item\n  async put(params: PutParams): Promise<void> {\n    const { Item } = params;\n    const tableName = this.getTableNameFromItem(Item);\n\n    try {\n      switch (tableName) {\n        case \"individuals\":\n          await db.individuals.put(Item as Individual);\n          break;\n        case \"grants\":\n          await db.grants.put(Item as Grant);\n          break;\n        case \"workdays\":\n          await db.workdays.put(Item as Workday);\n          break;\n        case \"workdayHours\":\n          await db.workdayHours.put(Item as WorkdayHours);\n          break;\n        case \"timeslots\":\n          const timeSlot = Item as TimeSlot;\n          // Validate business rules before putting\n          await this.validateTimeSlotConstraints(timeSlot);\n          await db.timeslots.put(timeSlot);\n          break;\n        default:\n          throw new Error(`Unknown table: ${tableName}`);\n      }\n    } catch (error) {\n      throw new Error(`Put operation failed: ${error}`);\n    }\n  }\n\n  // Get operation - Retrieve single item by key\n  async get(params: GetParams): Promise<{ Item?: DynamoDBItem }> {\n    const { Key } = params;\n    const tableName = this.getTableNameFromKey(Key);\n\n    try {\n      let item: any;\n\n      switch (tableName) {\n        case \"individuals\":\n          item = await db.individuals.get(Key.PK);\n          break;\n        case \"grants\":\n          item = await db.grants.get(Key.PK);\n          break;\n        case \"workdays\":\n          item = await db.workdays.get([Key.PK, Key.SK!]);\n          break;\n        case \"workdayHours\":\n          item = await db.workdayHours.get([Key.PK, Key.SK!]);\n          break;\n        case \"timeslots\":\n          item = await db.timeslots.get([Key.PK, Key.SK!]);\n          break;\n        default:\n          throw new Error(`Unknown table for key: ${JSON.stringify(Key)}`);\n      }\n\n      return item ? { Item: item } : {};\n    } catch (error) {\n      throw new Error(`Get operation failed: ${error}`);\n    }\n  }\n\n  // Delete operation - Delete single item\n  async deleteItem(params: DeleteParams): Promise<void> {\n    const { Key } = params;\n    const tableName = this.getTableNameFromKey(Key);\n\n    try {\n      switch (tableName) {\n        case \"individuals\":\n          await db.individuals.delete(Key.PK);\n          break;\n        case \"grants\":\n          await db.grants.delete(Key.PK);\n          break;\n        case \"workdays\":\n          await db.workdays.delete([Key.PK, Key.SK!]);\n          break;\n        case \"workdayHours\":\n          await db.workdayHours.delete([Key.PK, Key.SK!]);\n          break;\n        case \"timeslots\":\n          await db.timeslots.delete([Key.PK, Key.SK!]);\n          break;\n        default:\n          throw new Error(`Unknown table for key: ${JSON.stringify(Key)}`);\n      }\n    } catch (error) {\n      throw new Error(`Delete operation failed: ${error}`);\n    }\n  }\n\n  // Query operation - Query with partition key + optional sort key range\n  async query(params: QueryParams): Promise<{ Items: DynamoDBItem[] }> {\n    try {\n      // For simplicity, we'll handle basic queries\n      // In a real implementation, you'd parse the KeyConditionExpression\n\n      // Get all items from a table based on the query\n      let items: any[] = [];\n\n      // This is a simplified implementation\n      // You would need to implement proper query parsing for production\n\n      return { Items: items };\n    } catch (error) {\n      throw new Error(`Query operation failed: ${error}`);\n    }\n  }\n\n  // Batch write operation\n  async batchWrite(params: BatchWriteParams): Promise<void> {\n    const { RequestItems } = params;\n\n    try {\n      await db.transaction(\n        \"rw\",\n        [db.individuals, db.grants, db.workdays, db.workdayHours, db.timeslots],\n        async () => {\n          for (const [, requests] of Object.entries(RequestItems)) {\n            for (const request of requests) {\n              if (request.PutRequest) {\n                await this.put({ Item: request.PutRequest.Item });\n              } else if (request.DeleteRequest) {\n                await this.deleteItem({ Key: request.DeleteRequest.Key });\n              }\n            }\n          }\n        }\n      );\n    } catch (error) {\n      throw new Error(`Batch write operation failed: ${error}`);\n    }\n  }\n\n  // Transaction write operation - Atomic multi-item transactions\n  async transactWrite(params: TransactWriteParams): Promise<void> {\n    const { TransactItems } = params;\n\n    try {\n      await db.transaction(\n        \"rw\",\n        [db.individuals, db.grants, db.workdays, db.workdayHours, db.timeslots],\n        async () => {\n          for (const item of TransactItems) {\n            if (item.Put) {\n              await this.put({ Item: item.Put.Item });\n            } else if (item.Delete) {\n              await this.deleteItem({ Key: item.Delete.Key });\n            } else if (item.Update) {\n              await this.update(item.Update);\n            }\n          }\n        }\n      );\n    } catch (error) {\n      throw new Error(`Transaction write operation failed: ${error}`);\n    }\n  }\n\n  // Update operation - Update item with expressions\n  async update(params: UpdateParams): Promise<void> {\n    const { Key, UpdateExpression, ExpressionAttributeValues } = params;\n\n    try {\n      // Get existing item\n      const result = await this.get({ Key });\n      if (!result.Item) {\n        throw new Error(\"Item not found for update\");\n      }\n\n      // Apply update expression (simplified implementation)\n      const updatedItem = this.applyUpdateExpression(\n        result.Item,\n        UpdateExpression!,\n        ExpressionAttributeValues!\n      );\n\n      // Put updated item\n      await this.put({ Item: updatedItem });\n    } catch (error) {\n      throw new Error(`Update operation failed: ${error}`);\n    }\n  }\n\n  // Helper methods\n  private getTableNameFromItem(item: DynamoDBItem): string {\n    // Determine table based on item structure\n    if (\"FirstName\" in item && \"LastName\" in item) return \"individuals\";\n    if (\"Title\" in item && \"StartDate\" in item) return \"grants\";\n    if (\"Workdays\" in item) return \"workdays\";\n    if (\"Hours\" in item) return \"workdayHours\";\n    if (\"AllocationPercent\" in item || \"HoursAllocated\" in item)\n      return \"timeslots\";\n\n    throw new Error(\"Cannot determine table from item structure\");\n  }\n\n  private getTableNameFromKey(key: DynamoDBKey): string {\n    if (!key.SK) return key.PK.startsWith(\"U-\") ? \"individuals\" : \"grants\";\n\n    if (key.SK.startsWith(\"WORKDAYS#\")) return \"workdays\";\n    if (key.SK.startsWith(\"WORKDAY_HOURS#\")) return \"workdayHours\";\n    if (key.SK.includes(\"#G-\")) return \"timeslots\";\n\n    throw new Error(\"Cannot determine table from key structure\");\n  }\n\n  private applyUpdateExpression(\n    item: DynamoDBItem,\n    expression: string,\n    values: Record<string, any>\n  ): DynamoDBItem {\n    // Simplified update expression parser\n    const updated = { ...item };\n\n    // Handle SET operations\n    if (expression.includes(\"SET\")) {\n      const setClause = expression\n        .split(\"SET\")[1]\n        .split(\"ADD\")[0]\n        .split(\"REMOVE\")[0]\n        .trim();\n      const assignments = setClause.split(\",\");\n\n      for (const assignment of assignments) {\n        const [attr, valueRef] = assignment.split(\"=\").map((s) => s.trim());\n        if (values[valueRef]) {\n          updated[attr] = values[valueRef];\n        }\n      }\n    }\n\n    return updated;\n  }\n\n  private async validateTimeSlotConstraints(timeSlot: TimeSlot): Promise<void> {\n    // Get all existing time slots for the same user and date\n    const existingSlots = await db.timeslots\n      .where(\"PK\")\n      .equals(timeSlot.PK)\n      .and((item) => item.Date === timeSlot.Date && item.SK !== timeSlot.SK)\n      .toArray();\n\n    // Add the new slot for validation\n    const allSlots = [...existingSlots, timeSlot];\n\n    // Validate percentage constraint\n    if (!validateAllocationPercent(allSlots)) {\n      throw new Error(\"Total allocation percentage cannot exceed 100%\");\n    }\n\n    // Get available hours for the date\n    const year = new Date(timeSlot.Date).getFullYear();\n    const workdayHours = await db.workdayHours.get([\n      timeSlot.PK,\n      `WORKDAY_HOURS#${year}`,\n    ]);\n    const workdayEntry = workdayHours?.Hours[timeSlot.Date];\n    const availableHours = workdayEntry\n      ? getHoursFromDayEntry(workdayEntry)\n      : DEFAULT_WORKDAY_HOURS;\n\n    // Validate hours constraint\n    if (!validateHoursAllocated(allSlots, availableHours)) {\n      throw new Error(\n        `Total allocated hours cannot exceed ${availableHours} hours for this day`\n      );\n    }\n  }\n}\n\n// Export singleton instance\nexport const localDynamo = new LocalDynamoDB();\n"],"names":["db","open","catch","err","console","error","localDynamo","put","params","Item","tableName","this","getTableNameFromItem","individuals","grants","workdays","workdayHours","timeSlot","validateTimeSlotConstraints","timeslots","Error","concat","get","Key","getTableNameFromKey","item","PK","SK","JSON","stringify","deleteItem","delete","query","Items","batchWrite","RequestItems","transaction","async","requests","Object","entries","request","PutRequest","DeleteRequest","transactWrite","TransactItems","Put","Delete","Update","update","UpdateExpression","ExpressionAttributeValues","result","updatedItem","applyUpdateExpression","key","startsWith","includes","expression","values","updated","_objectSpread","assignments","split","trim","assignment","attr","valueRef","map","s","allSlots","where","equals","and","Date","toArray","validateAllocationPercent","year","getFullYear","workdayEntry","Hours","availableHours","getHoursFromDayEntry","DEFAULT_WORKDAY_HOURS","validateHoursAllocated"],"sourceRoot":""}